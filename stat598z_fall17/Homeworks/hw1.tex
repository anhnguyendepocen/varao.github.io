\documentclass[10pt]{article}
\usepackage{fullpage}
\usepackage{enumitem}
\usepackage{amsfonts}
\input{./base_style.sty}

       \hypersetup{
         colorlinks,
         urlcolor = red,
%         citecolor=green,
         linkcolor=black
       }



\def\cM{\mathcal{M}}
\def\cMI{\mathcal{S}}
\title{Stats 598z: Homework 1}
\author{Due before class on Thursday, Jan 26}
%.\\ All plots should have labelled axes and titles.\\
%}
\date{}
\begin{document}
\maketitle
\textbf{Important:\R\ code, tables and figures should be part of a single .pdf or .html files from {\tt R Markdown} and {\tt knitr}. 
See the class reading lists for a short tutorial.}

\section{Problem 1: The {\tt seq()} function \hfill [30]}
\begin{enumerate}
  \item We saw the `{\tt :}' operator generate integer vectors. A more flexible function in {\tt seq()}. Skim through
    the \R\ documentation to try and understand what this does. In particular, with examples explain the {\tt from, to,
    by} and {\tt length.out} options. \hfill [8pts]
  \item Note that you don't always have to specify all options, some missing values take
    default values. Explain what {\tt seq(10)} and {\tt seq(3,10)} do. \hfill [4pts]
  \item What happens when you pass {\tt seq()} a vector (of anything)? \hfill [4pts]
  \item What happens when you pass {\tt seq()} an integer vector of length 1? Note that this behaviour is inconsistent with
    the previous question and is often a source of bugs. \hfill [3pts]
  \item The {\tt seq\_along()} function avoids this inconsistency. Show this by using this with vector inputs from the
    previous two questions. \hfill [4pts]
  \item {\tt seq\_len(num)} is shorthand\footnote{not exactly: it's actually a more efficient implementation} for {\tt seq(from = 1, to = num, by = 1)}. 
    Use {\tt seq\_len} (and some basic arithmetic) to generate an
    \emph{integer}-vector from 3 to 10. \hfill [4pts]
  \item {\tt seq\_len(num)} resembles {\tt 1:num} unless num is negative. What happens then for both cases? \hfill [3pts]
\end{enumerate}

\section{Problem 2: Vectors in \R\hfill  [25]} 

  \R\ comes with a few built-in constant to make life easy for you. One such constant is {\tt letters}.
\begin{enumerate}
  \item Print out {\tt letters}. Also, print a summary of it. \hfill [3pts]
  \item What kind of data type is {\tt letters}? Include the commands you used to find this.\hfill [3pts]
  \item What is the length of {\tt letters}? Don't count!\hfill [2pts]
  \item How would you access every alternate element of {\tt letters}? Save the first, third, fifth etc.\ in an appropriately
    named variable.\hfill [4pts]
  \item How would you store {\tt letters} backwards in an appropriately named variable?\hfill [3pts]
  \item How would you store every alternate letters backwards in an appropriately named variable?\hfill [4pts]
\item Save the first 16 letters in a $4\times 4$ matrix.\hfill [3pts]
\item From the documentation of {\tt letters}, mention two other built-in constants and their data types.\hfill [3pts]
\end{enumerate}


\section{Problem 3: Matrices in \R\hfill  [45]} 
  {\tt runif()} generates numbers uniformly between $0$ and $1$ (we saw {\tt rnorm()} in class).
\begin{enumerate}
  \item Generate $20$ numbers uniformly between $0$ and $1$ and store them in a $4 \times 5$ matrix. \hfill[3pts]
  \item How would you index the entire third row of this matrix? What kind of data-structure is this? 
    What are its dimensions (if any)? \hfill[2pts]
  \item Repeat the previous with {\tt drop=FALSE}. See {\tt help('[')} for this option. \hfill[2pts]
  \item {\tt sum()} calculates the sum of all elements in the \R\ object. What is the sum of your matrix? \hfill[2pts]
  \item How would you transform your matrix so that the sum of all elements is $1$? \hfill[3pts]
  \item {\tt rowSums()} and {\tt colSums()} have self-explanatory names (though you should skim the documentation).
    Print their outputs for your matrix. \hfill[3pts]
  \item How would you transform your matrix so that its rows add up to one? Use recycling (and recall \R\ matrices are column-major). 
    You should not use {\tt for} loops, just material from the lectures \hfill[7pts]
  \item What does the function {\tt t()} do? \hfill[2pts]
  \item How would you transform your matrix so that its columns add up to one? Your answer will be similar to the previous
    one, except you will additionally have to use {\tt t()}. \hfill[7pts]
  \item Use {\tt runif()} to generate a new $2 \times 9$ matrix. Starting with this matrix, generate a new $3 \times 2$ matrix
    by picking every other element. There are two possibilities: every other element as you move along the rows, and every other
    element as you move along the columns. Provide code and results for both cases. Again, you might have to use {\tt t()}. \hfill [7pts]
  \item Look at the documentation for the {\tt cbind()} function. The example at the end has four lines: \\~\\
    {\tt\qquad \qquad m <- cbind(1, 1:7) \# the '1' (= shorter vector) is recycled \\
\qquad  \qquad m \\
  \qquad\qquad m <- cbind(m, 8:14)[, c(1, 3, 2)] \# insert a column \\
  \qquad\qquad m
}

Run these and print the output. Explain what is happening. Line 3 is a sequence of operations, and it might help to break them
down into the individual operations. \hfill[7pts]
\end{enumerate}
\end{document}
